<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>策略模式</title>
  </head>

  <body></body>
  <script>
    // 使用策略模式计算奖金
    // 例：绩效A奖金4倍；绩效B奖金3倍；绩效C奖金2倍；
    // 最初实现
    var countBonus1 = function (grade, salary) {
      if (grade === "A") {
        return salary * 4;
      }
      if (grade === "countBouns") {
        return salary * 3;
      }
      if (grade === "C") {
        return salary * 2;
      }
    };
    countBonus1("A", 20000);
    // 缺点：1、函数比较庞大，2、if分支较多，3、算法函数countBonus1缺乏弹性，如果再新增一个等级或者改某个绩效的奖金系数，此时我们必须深入countBonus内部实现，
    // 违反了开放-封闭原则；4、复用性差，其它地方需要用到的话，只能复制粘贴了，需要重构

    // 使用组合函数重构
    var performanceA = function (salary) {
      return salary * 4;
    };
    var performanceB = function (salary) {
      return salary * 3;
    };
    var performanceC = function (salary) {
      return salary * 2;
    };
    var countBonus2 = function (grade, salary) {
      if (grade === "A") {
        return performanceA(salary);
      }
      if (grade === "B") {
        return performanceB(salary);
      }
      if (grade === "C") {
        return performanceC(salary);
      }
    };
    countBonus2("A", 20000);
    // 缺点：countBonus2函数会越来越大，缺乏弹性

    // 使用策略模式重构
    // 一个基于策略模式的程序至少有两部分组成，
    // 一、一组策略类，策略类封装了一系列的具体算法，并负责具体的计算过程；
    // 二、环境类(Context),Context接受客户的请求，随后把请求委托给某一个策略类
    // 方法一 使用传统的面向对象（原型链继承）

    // 方法二 用javaScript实现策略模式
  </script>
</html>
